<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Echo Chambers - Sonar Cave Navigation Game | Kaiross</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Echo Chambers - Navigate through dark caves using sonar echolocation. A challenging arcade game with procedural terrain, Web Audio synthesis, and addictive gameplay. Made by Kaiross.">
    <meta name="keywords" content="echo chambers, sonar game, cave game, arcade game, web game, echolocation, kaiross, browser game, mobile game">
    <meta name="author" content="Kaiross">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://kaiross.in/echo-chambers">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kaiross.in/echo-chambers">
    <meta property="og:title" content="Echo Chambers - Sonar Cave Navigation Game | Kaiross">
    <meta property="og:description" content="Navigate through dark caves using sonar echolocation. Challenging arcade gameplay with procedural terrain and immersive audio.">
    <meta property="og:site_name" content="Kaiross">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://kaiross.in/echo-chambers">
    <meta name="twitter:title" content="Echo Chambers - Sonar Cave Navigation Game | Kaiross">
    <meta name="twitter:description" content="Navigate through dark caves using sonar echolocation. Challenging arcade gameplay with procedural terrain and immersive audio.">

    <!-- PWA / Mobile -->
    <meta name="theme-color" content="#050505">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Echo Chambers">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Prevent phone number detection -->
    <meta name="format-detection" content="telephone=no">

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "VideoGame",
        "name": "Echo Chambers",
        "description": "Navigate through dark caves using sonar echolocation. A challenging arcade game with procedural terrain and immersive audio.",
        "genre": ["Arcade", "Action"],
        "gamePlatform": ["Web Browser", "Mobile"],
        "applicationCategory": "Game",
        "operatingSystem": "Any",
        "author": {
            "@type": "Organization",
            "name": "Kaiross",
            "url": "https://kaiross.in"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Kaiross",
            "url": "https://kaiross.in"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@800&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #050505;
            overflow: hidden;
            touch-action: none;
            font-family: 'JetBrains Mono', monospace;
            cursor: crosshair;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #f0f0f0;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            z-index: 20;
        }

        .hud {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            left: max(20px, env(safe-area-inset-left));
            font-size: clamp(16px, 4vw, 24px);
            opacity: 0.8;
            font-variant-numeric: tabular-nums;
        }

        .branding {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            right: max(20px, env(safe-area-inset-right));
            font-size: clamp(10px, 2.5vw, 14px);
            opacity: 0.5;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: auto;
        }

        .branding a {
            color: #f0f0f0;
            text-decoration: none;
            transition: opacity 0.2s;
        }

        .branding a:hover {
            opacity: 1;
        }

        .sound-toggle {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }

        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .sound-toggle:active {
            transform: scale(0.9);
        }

        .sound-toggle.muted {
            opacity: 0.5;
        }

        .warning-box {
            position: absolute;
            bottom: 20%;
            width: 100%;
            text-align: center;
            font-size: clamp(14px, 4vw, 20px);
            color: #ff4444;
            text-shadow: 0 0 10px #ff0000;
            font-weight: bold;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.2s;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .warning-active {
            opacity: 1;
            animation: flash 0.5s infinite alternate;
        }

        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.2; }
        }

        .start-screen, .game-over-screen {
            background: rgba(10, 10, 10, 0.95);
            padding: clamp(1.5rem, 5vw, 2.5rem);
            border: 2px solid #fff;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(255,255,255,0.1);
            transition: opacity 0.3s;
            max-width: 90vw;
            margin: 20px;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: clamp(1.5rem, 8vw, 3rem);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: clamp(3px, 1vw, 6px);
            color: #fff;
        }

        p {
            font-size: clamp(0.75rem, 3vw, 1rem);
            margin-bottom: 1.5rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn {
            background: #fff;
            color: #000;
            border: none;
            padding: clamp(12px, 3vw, 16px) clamp(24px, 6vw, 32px);
            font-size: clamp(0.9rem, 3vw, 1.2rem);
            font-family: inherit;
            font-weight: 800;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.1s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 48px;
            min-width: 48px;
        }

        .btn:hover {
            background: #ddd;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
            background: #ccc;
        }

        .tap-hint {
            font-size: clamp(0.6rem, 2.5vw, 0.8rem);
            color: #666;
            margin-top: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 480px) {
            .start-screen, .game-over-screen {
                padding: 1.25rem;
            }
        }

        /* Leaderboard Styles */
        .leaderboard {
            margin-top: 1rem;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
        }

        .leaderboard-title {
            font-size: clamp(0.8rem, 3vw, 1rem);
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 0.5rem;
        }

        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: clamp(0.7rem, 2.5vw, 0.85rem);
        }

        .leaderboard-list li {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .leaderboard-list li.current-player {
            color: #4f4;
        }

        .leaderboard-rank {
            width: 25px;
            text-align: left;
            color: #666;
        }

        .leaderboard-name {
            flex: 1;
            text-align: left;
            padding: 0 0.5rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-score {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        /* Name Input Modal */
        .name-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .name-modal-content {
            background: rgba(10, 10, 10, 0.95);
            padding: clamp(1.5rem, 5vw, 2.5rem);
            border: 2px solid #fff;
            text-align: center;
            max-width: 90vw;
        }

        .name-input {
            background: #000;
            border: 1px solid #fff;
            color: #fff;
            padding: 12px 16px;
            font-size: 1rem;
            font-family: inherit;
            width: 100%;
            max-width: 200px;
            text-align: center;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .name-input:focus {
            outline: none;
            border-color: #4f4;
        }

        .name-input::placeholder {
            color: #444;
        }

        /* Logo Styles */
        .game-logo {
            margin-bottom: 1.5rem;
        }

        .game-logo svg {
            width: clamp(80px, 20vw, 120px);
            height: auto;
            filter: drop-shadow(0 0 10px rgba(192, 192, 192, 0.3));
        }

        .logo-text {
            font-size: clamp(1.8rem, 8vw, 3rem);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: clamp(3px, 1vw, 6px);
            background: linear-gradient(180deg, #e8e8e8 0%, #a0a0a0 50%, #c0c0c0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }

        /* Visual FX */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.9) 100%);
            pointer-events: none;
            z-index: 9;
        }

        .noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.05;
            pointer-events: none;
            z-index: 8;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>
    <div class="vignette"></div>
    <div class="noise"></div>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="hud" id="scoreDisplay">DEPTH: 0m</div>
        <button class="sound-toggle" id="soundToggle" aria-label="Toggle sound">ðŸ”Š</button>
        <div id="warningDisplay" class="warning-box">TERRAIN PROXIMITY</div>
        <!-- New Difficulty Notification -->
        <div id="difficultyDisplay" class="warning-box" style="color: #fff; bottom: 50%;"></div>

        <div id="startScreen" class="start-screen">
            <div class="game-logo">
                <!-- Geometric Bat Logo - Straight Lines Only -->
                <svg viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg">
                    <!-- Left wing - angular geometric shape -->
                    <polygon points="42,28 35,22 20,18 5,22 8,32 12,38 18,36 22,42 28,38 32,44 38,40 42,46" fill="#c0c0c0"/>
                    <!-- Right wing - angular geometric shape -->
                    <polygon points="58,28 65,22 80,18 95,22 92,32 88,38 82,36 78,42 72,38 68,44 62,40 58,46" fill="#c0c0c0"/>
                    <!-- Body - hexagon -->
                    <polygon points="50,24 56,30 56,42 50,48 44,42 44,30" fill="#c0c0c0"/>
                    <!-- Head - pentagon -->
                    <polygon points="50,14 56,18 54,24 46,24 44,18" fill="#c0c0c0"/>
                    <!-- Left ear - triangle -->
                    <polygon points="44,16 40,6 46,12" fill="#c0c0c0"/>
                    <!-- Right ear - triangle -->
                    <polygon points="56,16 60,6 54,12" fill="#c0c0c0"/>
                    <!-- Eyes - small diamonds -->
                    <polygon points="47,18 48,17 49,18 48,19" fill="#000"/>
                    <polygon points="51,18 52,17 53,18 52,19" fill="#000"/>
                    <!-- Sonar waves - angular lines -->
                    <path d="M 50,26 L 45,30 L 40,28" stroke="#808080" stroke-width="1" fill="none" opacity="0.6"/>
                    <path d="M 50,26 L 55,30 L 60,28" stroke="#808080" stroke-width="1" fill="none" opacity="0.6"/>
                    <path d="M 50,26 L 42,32 L 35,29" stroke="#808080" stroke-width="1" fill="none" opacity="0.3"/>
                    <path d="M 50,26 L 58,32 L 65,29" stroke="#808080" stroke-width="1" fill="none" opacity="0.3"/>
                </svg>
            </div>
            <h1 class="logo-text">Echo Chambers</h1>
            <p>Enable Audio for Best Experience</p>
            <button class="btn" id="startBtn">Initialize Sonar</button>
            <div class="tap-hint">Tap or Space to Fly</div>
        </div>

        <div id="gameOverScreen" class="game-over-screen hidden">
            <h1 style="color: #fff;">SIGNAL LOST</h1>
            <p id="finalScore">Depth Reached: 0m</p>
            <div class="leaderboard">
                <div class="leaderboard-title">Top Explorers</div>
                <ul class="leaderboard-list" id="leaderboardList">
                    <li><span class="leaderboard-rank">-</span><span class="leaderboard-name">Loading...</span><span class="leaderboard-score">-</span></li>
                </ul>
            </div>
            <button class="btn" id="restartBtn">Reboot System</button>
            <div class="tap-hint">Tap or Space to Fly</div>
        </div>

        <!-- Name Input Modal -->
        <div id="nameModal" class="name-modal hidden">
            <div class="name-modal-content">
                <h1 style="font-size: clamp(1.2rem, 5vw, 1.8rem);">Enter Your Name</h1>
                <p style="margin-bottom: 1rem;">For the leaderboard</p>
                <input type="text" id="playerNameInput" class="name-input" placeholder="NAME" maxlength="15" autocomplete="off">
                <br>
                <button class="btn" id="submitNameBtn">Confirm</button>
            </div>
        </div>

        <div class="branding">
            <a href="https://kaiross.in" target="_blank" rel="noopener">Kaiross.in</a>
        </div>
    </div>

    <script>
        /* * ECHO CHAMBERS - AUDIO & VISUAL UPDATE
         * Features:
         * - Web Audio API Synthesis
         * - Visual Echo Bounce Physics
         * - Improved Cave/Air Separation
         * - Smart Auto-Pilot
         * - Safety Net for first 50m
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // UI Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const warningDisplay = document.getElementById('warningDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay'); // New element
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');

        // Game State
        let gameState = 'START';
        let score = 0;
        let lastTime = 0;
        let gameSpeed = 250;
        let frames = 0;
        let countdownTimer = 0;
        let warningTimer = 0;
        let difficultyTimer = 0; // Timer for notification

        // Gameplay Enhancement State
        let scoreMultiplier = 1.0;
        let lastMilestone = 0;
        let milestoneTimer = 0;
        let personalBest = parseInt(localStorage.getItem('echoChambersBest') || '0');
        let nearMissTimer = 0;
        let deathSlowMo = false;
        let deathSlowMoTimer = 0;
        let baseSpeed = 280;
        let speedPhase = 0; // For speed variation
        let comboStreak = 0; // Near-wall flying streak
        let lastProximity = 0;

        // Leaderboard state
        let playerName = localStorage.getItem('echoChambersName') || '';
        let playerId = localStorage.getItem('echoChambersPlayerId') || '';
        let pendingScore = 0;

        // Generate player ID if not exists
        if (!playerId) {
            playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('echoChambersPlayerId', playerId);
        }

        // Leaderboard API functions
        async function fetchLeaderboard() {
            try {
                const response = await fetch('/api/scores');
                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.error('Failed to fetch leaderboard:', error);
            }
            return [];
        }

        async function submitScore(name, score) {
            try {
                const response = await fetch('/api/scores', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, score, playerId })
                });
                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.error('Failed to submit score:', error);
            }
            return null;
        }

        function renderLeaderboard(scores, currentScore) {
            const list = document.getElementById('leaderboardList');
            if (scores.length === 0) {
                list.innerHTML = '<li><span class="leaderboard-rank">-</span><span class="leaderboard-name">No scores yet</span><span class="leaderboard-score">-</span></li>';
                return;
            }

            list.innerHTML = scores.map((entry, index) => {
                const isCurrentPlayer = entry.playerId === playerId && entry.score === currentScore;
                return `<li class="${isCurrentPlayer ? 'current-player' : ''}">
                    <span class="leaderboard-rank">${index + 1}.</span>
                    <span class="leaderboard-name">${entry.name}</span>
                    <span class="leaderboard-score">${entry.score}m</span>
                </li>`;
            }).join('');
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // ------------------------------------------------------------------
        // SOUND SYSTEM (Web Audio API)
        // ------------------------------------------------------------------
        class SoundSystem {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.muted = false;
                this.masterGain = null;
            }

            init() {
                if (this.initialized) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                // Create master gain for mute control
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);

                this.initialized = true;

                // Create Ambience Drone
                this.createAmbience();
            }

            toggleMute() {
                this.muted = !this.muted;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.muted ? 0 : 1;
                }
                return this.muted;
            }

            setMuted(muted) {
                this.muted = muted;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.muted ? 0 : 1;
                }
            }

            createAmbience() {
                if (!this.ctx) return;
                // Pink Noise Generator for Wind
                const bufferSize = 2 * this.ctx.sampleRate;
                const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);

                let lastOut = 0;

                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    output[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = output[i];
                    output[i] *= 3.5;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;

                const gain = this.ctx.createGain();
                gain.gain.value = 0.05;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }

            playPing() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(400, t + 0.1);

                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                osc.stop(t + 0.3);
            }

            playBounce(volume = 1.0) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, t);
                osc.frequency.linearRampToValueAtTime(1000, t + 0.05);

                gain.gain.setValueAtTime(0.05 * volume, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.05);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                osc.stop(t + 0.05);
            }

            playCrash() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);

                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                osc.stop(t + 0.5);
            }

            playWarning() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'square';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.15);

                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                osc.stop(t + 0.15);
            }

            playMilestone() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                // Triumphant rising tone
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc1.type = 'sine';
                osc2.type = 'sine';

                osc1.frequency.setValueAtTime(400, t);
                osc1.frequency.linearRampToValueAtTime(800, t + 0.15);
                osc2.frequency.setValueAtTime(600, t);
                osc2.frequency.linearRampToValueAtTime(1200, t + 0.15);

                gain.gain.setValueAtTime(0.2, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);

                osc1.start(t);
                osc2.start(t);
                osc1.stop(t + 0.3);
                osc2.stop(t + 0.3);
            }

            playNearMiss() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, t);
                osc.frequency.linearRampToValueAtTime(400, t + 0.08);

                gain.gain.setValueAtTime(0.15, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.08);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                osc.stop(t + 0.08);
            }
        }

        // ------------------------------------------------------------------
        // LOGIC CLASSES
        // ------------------------------------------------------------------

        class Bat {
            constructor() {
                this.x = canvas.width * 0.2;
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.gravity = 1600;
                this.jumpStrength = -450;
                this.angle = 0;
                this.radius = 8;
            }

            reset() {
                this.x = canvas.width * 0.2;
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.angle = 0;
            }

            update(dt) {
                this.velocity += this.gravity * dt;
                this.y += this.velocity * dt;
                if (this.velocity > 800) this.velocity = 800;
                this.angle = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1) * (Math.PI / 180)));

                // Collision with floor/ceiling bounds
                if (this.y < 0 || this.y > canvas.height) return true;
                return false;
            }

            flap() {
                this.velocity = this.jumpStrength;
                fxSystem.addEcho(this.x, this.y);
                soundSystem.playPing();
                fxSystem.addParticles(this.x, this.y, 8);
            }

            // Helper for auto-pilot to flap without user sound/particles spam
            autoFlap() {
                this.velocity = this.jumpStrength;
                if(Math.random() > 0.7) fxSystem.addParticles(this.x, this.y, 3); // Fewer particles
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(-6, 6);
                ctx.lineTo(-2, 0);
                ctx.lineTo(-6, -6);
                ctx.closePath();
                ctx.fill();
                // Eye
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(4, -1, 1.5, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
        }

        class TerrainManager {
            constructor() {
                this.segments = [];
                this.segmentWidth = 20;
                this.gapSize = 280;
                this.minGap = 150;
                this.maxGap = 350;
                this.noiseOffset = 0;
                this.roughness = 60;

                // Difficulty Tracking
                this.currentStage = 0;

                // --- NEW TERRAIN STATE VARIABLES ---
                this.centerY = canvas.height / 2;
                this.slope = 0;
                this.terrainState = 'STABLE'; // STABLE, UP, DOWN, VOLATILE
                this.stateTimer = 0;

                // Organic wave for natural cave feel
                this.waveOffset = 0;
                this.waveFreq1 = 0.02 + Math.random() * 0.01;
                this.waveFreq2 = 0.035 + Math.random() * 0.015;
                this.waveFreq3 = 0.008 + Math.random() * 0.005;

                this.fill();
            }

            reset() {
                this.segments = [];
                this.noiseOffset = 0;
                this.gapSize = 280;
                this.currentStage = 0;

                // Reset State
                this.centerY = canvas.height / 2;
                this.slope = 0;
                this.terrainState = 'STABLE';
                this.stateTimer = 0;

                // Reset waves with new random frequencies
                this.waveOffset = 0;
                this.waveFreq1 = 0.02 + Math.random() * 0.01;
                this.waveFreq2 = 0.035 + Math.random() * 0.015;
                this.waveFreq3 = 0.008 + Math.random() * 0.005;

                this.fill();
            }

            fill() {
                let x = 0;
                while (x < canvas.width + 100) {
                    this.addSegment(x);
                    x += this.segmentWidth;
                }
            }

            addSegment(x) {
                // Increment wave offset for organic movement
                this.waveOffset++;

                // Safe Zone Logic (Start of game)
                let difficultyScale = 0;
                const safeZoneEnd = canvas.width * 0.3;
                const rampUpZone = canvas.width * 0.6;

                if (x > safeZoneEnd) {
                    difficultyScale = (x - safeZoneEnd) / (rampUpZone - safeZoneEnd);
                    difficultyScale = Math.min(1, difficultyScale);
                }

                // --- DIFFICULTY STAGE SETTINGS (INCREASED) ---
                let currentGap = 280;
                let currentRoughness = 60;

                if (difficultyScale >= 1) {
                    if (score < 300) {
                        currentGap = 240;
                        currentRoughness = 70;
                    } else if (score < 600) {
                        currentGap = 200;
                        currentRoughness = 90;
                    } else if (score < 1000) {
                        currentGap = 170;
                        currentRoughness = 110;
                    } else {
                        currentGap = 140;
                        currentRoughness = 130;
                    }
                    // Add random variation to gap
                    currentGap += (Math.random() * 30 - 15);
                } else {
                    currentGap = 300; // Slightly narrower at start for more interest
                }

                // --- ORGANIC WAVE MOVEMENT (Always active for natural feel) ---
                // Multiple sine waves create natural, unpredictable cave paths
                const wave1 = Math.sin(this.waveOffset * this.waveFreq1) * 80;  // Slow big wave
                const wave2 = Math.sin(this.waveOffset * this.waveFreq2) * 40;  // Medium wave
                const wave3 = Math.sin(this.waveOffset * this.waveFreq3) * 120; // Very slow drift

                // Base organic movement - always present
                let organicOffset = (wave1 + wave2 + wave3) * (0.3 + difficultyScale * 0.7);

                // --- TERRAIN STATE MACHINE (The "Brain" of the cave) ---
                // States add extra challenge on top of organic movement
                if (difficultyScale >= 0.3) {
                    if (this.stateTimer <= 0) {
                        // Pick a new state
                        const rand = Math.random();

                        if (rand < 0.25) {
                            this.terrainState = 'STABLE';
                            this.stateTimer = Math.floor(Math.random() * 25 + 15);
                            this.slope = (Math.random() - 0.5) * 1.5;
                        }
                        else if (rand < 0.50) {
                            this.terrainState = 'UP';
                            this.stateTimer = Math.floor(Math.random() * 20 + 12);
                            this.slope = -(Math.random() * 3.5 + 2);
                        }
                        else if (rand < 0.75) {
                            this.terrainState = 'DOWN';
                            this.stateTimer = Math.floor(Math.random() * 20 + 12);
                            this.slope = (Math.random() * 3.5 + 2);
                        }
                        else {
                            this.terrainState = 'VOLATILE';
                            this.stateTimer = Math.floor(Math.random() * 12 + 8);
                            this.slope = 0;
                        }
                    }
                    this.stateTimer--;
                } else {
                    // Gentle states at start - still some movement!
                    if (this.stateTimer <= 0) {
                        const rand = Math.random();
                        if (rand < 0.5) {
                            this.terrainState = 'STABLE';
                            this.slope = (Math.random() - 0.5) * 0.8;
                        } else if (rand < 0.75) {
                            this.terrainState = 'UP';
                            this.slope = -(Math.random() * 1.5 + 0.5);
                        } else {
                            this.terrainState = 'DOWN';
                            this.slope = (Math.random() * 1.5 + 0.5);
                        }
                        this.stateTimer = Math.floor(Math.random() * 30 + 20);
                    }
                    this.stateTimer--;
                }

                // --- APPLY STATE TO CENTER Y ---
                if (this.terrainState === 'VOLATILE') {
                    this.centerY += (Math.random() - 0.5) * 30;
                } else {
                    this.centerY += this.slope;
                }

                // Apply organic wave on top of state-based movement
                let finalCenterY = this.centerY + organicOffset;

                // --- BOUNDARY CHECKS (Keep cave on screen) ---
                const padding = currentGap / 2 + 60;

                if (finalCenterY < padding) {
                    this.centerY = padding - organicOffset;
                    finalCenterY = padding;
                    this.terrainState = 'DOWN';
                    this.slope = 2;
                    this.stateTimer = 20;
                }
                if (finalCenterY > canvas.height - padding) {
                    this.centerY = (canvas.height - padding) - organicOffset;
                    finalCenterY = canvas.height - padding;
                    this.terrainState = 'UP';
                    this.slope = -2;
                    this.stateTimer = 20;
                }

                // --- GENERATE TOP AND BOTTOM POINTS ---
                // Base roughness even at start for texture
                let baseRoughness = 15;
                let jaggedMult = 1.0;
                if (this.terrainState === 'VOLATILE') jaggedMult = 2.0;

                const totalRoughness = baseRoughness + (currentRoughness * difficultyScale * jaggedMult);
                const jaggedTop = (Math.random() - 0.3) * totalRoughness;
                const jaggedBot = (Math.random() - 0.3) * totalRoughness;

                const topY = finalCenterY - (currentGap / 2) + jaggedTop;
                const botY = finalCenterY + (currentGap / 2) + jaggedBot;

                this.segments.push({
                    x: x,
                    w: this.segmentWidth,
                    top: topY,
                    bot: botY
                });
            }

            update(dt) {
                const moveAmount = gameSpeed * dt;
                if (this.segments.length > 0 && this.segments[0].x + this.segments[0].w < -100) {
                    this.segments.shift();
                }
                for (let s of this.segments) {
                    s.x -= moveAmount;
                }
                const lastSeg = this.segments[this.segments.length - 1];
                if (lastSeg.x < canvas.width + 100) {
                    this.addSegment(lastSeg.x + this.segmentWidth);
                }
                // Speed is now managed in main loop with variation
            }

            checkCollision(bat) {
                const bx = bat.x;
                const by = bat.y;
                const br = bat.radius * 0.8;

                for (let s of this.segments) {
                    if (bx + br > s.x && bx - br < s.x + s.w) {
                        if (by - br < s.top) return true;
                        if (by + br > s.bot) return true;
                    }
                }
                return false;
            }

            // Draw the visual outline of the cave with smooth curves
            draw(ctx) {
                ctx.strokeStyle = '#444'; // Lighter grey for better visibility
                ctx.lineWidth = 2;

                if (this.segments.length < 2) return;

                // Draw smooth top outline using quadratic curves
                ctx.beginPath();
                let firstX = this.segments[0].x + this.segments[0].w / 2;
                let firstTopY = this.segments[0].top;
                ctx.moveTo(this.segments[0].x - 50, firstTopY);
                ctx.lineTo(firstX, firstTopY);

                for (let i = 0; i < this.segments.length - 1; i++) {
                    const curr = this.segments[i];
                    const next = this.segments[i + 1];
                    const currMidX = curr.x + curr.w / 2;
                    const nextMidX = next.x + next.w / 2;
                    const cpX = (currMidX + nextMidX) / 2;
                    ctx.quadraticCurveTo(currMidX, curr.top, cpX, (curr.top + next.top) / 2);
                }
                // Final segment
                const last = this.segments[this.segments.length - 1];
                ctx.lineTo(last.x + last.w + 50, last.top);
                ctx.stroke();

                // Draw smooth bottom outline
                ctx.beginPath();
                let firstBotY = this.segments[0].bot;
                ctx.moveTo(this.segments[0].x - 50, firstBotY);
                ctx.lineTo(firstX, firstBotY);

                for (let i = 0; i < this.segments.length - 1; i++) {
                    const curr = this.segments[i];
                    const next = this.segments[i + 1];
                    const currMidX = curr.x + curr.w / 2;
                    const nextMidX = next.x + next.w / 2;
                    const cpX = (currMidX + nextMidX) / 2;
                    ctx.quadraticCurveTo(currMidX, curr.bot, cpX, (curr.bot + next.bot) / 2);
                }
                ctx.lineTo(last.x + last.w + 50, last.bot);
                ctx.stroke();
            }

            // Draw the solid rock that covers everything with smooth curves
            drawMask(ctx) {
                ctx.fillStyle = '#000000'; // Pure Black Rocks

                if (this.segments.length < 2) return;

                // Ceiling with smooth curve
                ctx.beginPath();
                ctx.moveTo(this.segments[0].x - 50, -50);

                let firstX = this.segments[0].x + this.segments[0].w / 2;
                ctx.lineTo(this.segments[0].x - 50, this.segments[0].top);
                ctx.lineTo(firstX, this.segments[0].top);

                for (let i = 0; i < this.segments.length - 1; i++) {
                    const curr = this.segments[i];
                    const next = this.segments[i + 1];
                    const currMidX = curr.x + curr.w / 2;
                    const nextMidX = next.x + next.w / 2;
                    const cpX = (currMidX + nextMidX) / 2;
                    ctx.quadraticCurveTo(currMidX, curr.top, cpX, (curr.top + next.top) / 2);
                }

                const last = this.segments[this.segments.length - 1];
                ctx.lineTo(last.x + last.w + 50, last.top);
                ctx.lineTo(last.x + last.w + 50, -50);
                ctx.closePath();
                ctx.fill();

                // Floor with smooth curve
                ctx.beginPath();
                ctx.moveTo(this.segments[0].x - 50, canvas.height + 50);
                ctx.lineTo(this.segments[0].x - 50, this.segments[0].bot);
                ctx.lineTo(firstX, this.segments[0].bot);

                for (let i = 0; i < this.segments.length - 1; i++) {
                    const curr = this.segments[i];
                    const next = this.segments[i + 1];
                    const currMidX = curr.x + curr.w / 2;
                    const nextMidX = next.x + next.w / 2;
                    const cpX = (currMidX + nextMidX) / 2;
                    ctx.quadraticCurveTo(currMidX, curr.bot, cpX, (curr.bot + next.bot) / 2);
                }

                ctx.lineTo(last.x + last.w + 50, last.bot);
                ctx.lineTo(last.x + last.w + 50, canvas.height + 50);
                ctx.closePath();
                ctx.fill();
            }

            // Helper for Echo Bounce Physics
            getSegmentAt(x) {
                for(let s of this.segments) {
                    if(x >= s.x && x < s.x + s.w) return s;
                }
                return null;
            }
        }

        class FXSystem {
            constructor() {
                this.particles = [];
                this.echoes = [];
            }

            addParticles(x, y, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 150,
                        vy: (Math.random() - 0.5) * 150,
                        life: 1.0,
                        size: Math.random() * 2 + 1
                    });
                }
            }

            addEcho(x, y, isBounce = false) {
                this.echoes.push({
                    x: x,
                    y: y,
                    radius: isBounce ? 2 : 10,
                    alpha: isBounce ? 0.6 : 1.0,
                    maxRadius: isBounce ? 60 : 400,
                    speed: isBounce ? 200 : 500,
                    isBounce: isBounce,
                    hasBouncedTop: false,
                    hasBouncedBot: false
                });
            }

            update(dt, terrain) {
                // Particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt * 3;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }

                // Echoes Logic
                for (let i = this.echoes.length - 1; i >= 0; i--) {
                    let e = this.echoes[i];
                    e.radius += dt * e.speed;
                    e.alpha -= dt * (e.isBounce ? 1.5 : 0.8);
                    e.x -= gameSpeed * dt * 0.8;

                    // --- ECHO BOUNCE LOGIC ---
                    if (!e.isBounce && e.alpha > 0.1) {
                        const seg = terrain.getSegmentAt(e.x);

                        if (seg) {
                            // Check Top Bounce
                            if (!e.hasBouncedTop && (e.y - e.radius <= seg.top)) {
                                e.hasBouncedTop = true;
                                this.addEcho(e.x, seg.top, true); // Spawn ripple
                                soundSystem.playBounce(e.alpha); // Play sound
                            }
                            // Check Bottom Bounce
                            if (!e.hasBouncedBot && (e.y + e.radius >= seg.bot)) {
                                e.hasBouncedBot = true;
                                this.addEcho(e.x, seg.bot, true); // Spawn ripple
                                soundSystem.playBounce(e.alpha); // Play sound
                            }
                        }
                    }

                    if (e.alpha <= 0) this.echoes.splice(i, 1);
                }
            }

            draw(ctx) {
                for (let e of this.echoes) {
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);

                    const grad = ctx.createRadialGradient(e.x, e.y, Math.max(0, e.radius - 10), e.x, e.y, e.radius + 5);

                    if (e.isBounce) {
                        // Bounce ripples are cyan tinted slightly
                        grad.addColorStop(0, `rgba(200,255,255,0)`);
                        grad.addColorStop(0.5, `rgba(200,255,255,${e.alpha})`);
                        grad.addColorStop(1, `rgba(200,255,255,0)`);
                    } else {
                        // Main sonar is white
                        grad.addColorStop(0, `rgba(255,255,255,0)`);
                        grad.addColorStop(0.5, `rgba(255,255,255,${e.alpha})`);
                        grad.addColorStop(1, `rgba(255,255,255,0)`);
                    }

                    ctx.lineWidth = e.isBounce ? 5 : 20;
                    ctx.strokeStyle = grad;
                    ctx.stroke();
                }

                ctx.fillStyle = '#fff';
                for (let p of this.particles) {
                    ctx.globalAlpha = p.life;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        // ------------------------------------------------------------------
        // MAIN LOGIC
        // ------------------------------------------------------------------

        const bat = new Bat();
        const terrain = new TerrainManager();
        const fxSystem = new FXSystem();
        const soundSystem = new SoundSystem();

        function resetGame() {
            soundSystem.init(); // Initialize audio context on interaction
            score = 0;
            gameSpeed = 250;
            bat.reset();
            terrain.reset();
            fxSystem.particles = [];
            fxSystem.echoes = [];

            // Reset gameplay enhancement state
            scoreMultiplier = 1.0;
            lastMilestone = 0;
            milestoneTimer = 0;
            nearMissTimer = 0;
            deathSlowMo = false;
            deathSlowMoTimer = 0;
            baseSpeed = 280;
            speedPhase = 0;
            comboStreak = 0;
            lastProximity = 0;

            // Start Immediately
            gameState = 'PLAYING';
            warningTimer = 0;
            difficultyTimer = 0; // Reset diff timer
            difficultyDisplay.classList.remove('warning-active');
            warningDisplay.classList.remove('warning-active');

            scoreDisplay.innerText = "DEPTH: 0m";

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');

            fxSystem.addEcho(bat.x, bat.y);
        }

        async function gameOver() {
            // Save personal best
            const finalScore = Math.floor(score);
            if (finalScore > personalBest) {
                personalBest = finalScore;
                localStorage.setItem('echoChambersBest', personalBest.toString());
            }

            // Start death slow-mo
            deathSlowMo = true;
            deathSlowMoTimer = 0.4; // 0.4 seconds of slow-mo

            gameState = 'GAMEOVER';
            soundSystem.playCrash();

            // Show score with personal best
            if (finalScore >= personalBest && finalScore > 0) {
                finalScoreDisplay.innerHTML = `Depth: ${finalScore}m<br><span style="color: #4f4; font-size: 0.8em;">NEW BEST!</span>`;
            } else {
                finalScoreDisplay.innerHTML = `Depth: ${finalScore}m<br><span style="color: #888; font-size: 0.7em;">Best: ${personalBest}m</span>`;
            }

            warningDisplay.classList.remove('warning-active');

            const intensity = 15;
            canvas.style.transform = `translate(${Math.random()*intensity-intensity/2}px, ${Math.random()*intensity-intensity/2}px)`;
            setTimeout(() => { canvas.style.transform = 'none'; }, 100);

            fxSystem.addParticles(bat.x, bat.y, 50);

            // Handle leaderboard submission
            pendingScore = finalScore;

            // Delay for slow-mo effect
            setTimeout(async () => {
                if (!playerName) {
                    // Show name modal for first-time players
                    document.getElementById('nameModal').classList.remove('hidden');
                    document.getElementById('playerNameInput').focus();
                } else {
                    // Submit score immediately for returning players
                    try {
                        await submitScore(playerName, finalScore);
                        const scores = await fetchLeaderboard();
                        renderLeaderboard(scores, finalScore);
                    } catch (error) {
                        console.error('Leaderboard error:', error);
                        renderLeaderboard([], 0);
                    }
                    gameOverScreen.classList.remove('hidden');
                }
            }, 400);
        }

        // Name modal handling - wait for DOM
        const nameModal = document.getElementById('nameModal');
        const playerNameInput = document.getElementById('playerNameInput');
        const submitNameBtn = document.getElementById('submitNameBtn');

        async function handleNameSubmit() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim().toUpperCase();

            console.log('handleNameSubmit called, name:', name);

            if (name.length > 0) {
                playerName = name;
                localStorage.setItem('echoChambersName', playerName);

                console.log('Submitting score:', pendingScore, 'for player:', playerName);

                // Hide modal first
                document.getElementById('nameModal').classList.add('hidden');

                // Submit score and show leaderboard
                try {
                    const result = await submitScore(playerName, pendingScore);
                    console.log('Score submitted:', result);
                    const scores = await fetchLeaderboard();
                    console.log('Leaderboard fetched:', scores);
                    renderLeaderboard(scores, pendingScore);
                } catch (error) {
                    console.error('Leaderboard error:', error);
                    renderLeaderboard([], 0);
                }
                gameOverScreen.classList.remove('hidden');
            } else {
                console.log('Name is empty, not submitting');
            }
        }

        // Attach event listeners
        if (submitNameBtn) {
            submitNameBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Submit button clicked');
                handleNameSubmit();
            });

            submitNameBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Submit button touched');
                handleNameSubmit();
            });
        } else {
            console.error('submitNameBtn not found!');
        }

        if (playerNameInput) {
            playerNameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    console.log('Enter pressed in name input');
                    handleNameSubmit();
                }
            });
        } else {
            console.error('playerNameInput not found!');
        }

        function handleInput() {
            soundSystem.init();
            if (gameState === 'PLAYING') {
                bat.flap();
            }
        }

        // Detect if device supports touch
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'PLAYING') handleInput();
            }
        });

        // Mouse Click Listener (desktop)
        window.addEventListener('mousedown', (e) => {
            // Ignore clicks on buttons
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A') return;
            if (gameState === 'PLAYING') handleInput();
        });

        // Enhanced touch controls for mobile
        let lastTouchTime = 0;

        window.addEventListener('touchstart', (e) => {
            // Prevent double-tap zoom
            const now = Date.now();
            if (now - lastTouchTime < 300) {
                e.preventDefault();
            }
            lastTouchTime = now;

            // Ignore touches on buttons
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A') return;

            e.preventDefault();
            if (gameState === 'PLAYING') handleInput();
        }, {passive: false});

        // Prevent default touch behaviors that interfere with game
        window.addEventListener('touchmove', (e) => {
            if (gameState === 'PLAYING') {
                e.preventDefault();
            }
        }, {passive: false});

        window.addEventListener('touchend', (e) => {
            if (gameState === 'PLAYING') {
                e.preventDefault();
            }
        }, {passive: false});

        // Prevent context menu on long press
        window.addEventListener('contextmenu', (e) => {
            if (gameState === 'PLAYING') {
                e.preventDefault();
            }
        });

        startBtn.addEventListener('click', resetGame);
        restartBtn.addEventListener('click', resetGame);

        // Also handle touch on buttons for faster response
        startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetGame();
        });
        restartBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetGame();
        });

        // Sound toggle
        const soundToggle = document.getElementById('soundToggle');
        soundToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            soundSystem.init(); // Ensure audio context exists
            const muted = soundSystem.toggleMute();
            soundToggle.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
            soundToggle.classList.toggle('muted', muted);
        });
        soundToggle.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            soundSystem.init();
            const muted = soundSystem.toggleMute();
            soundToggle.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
            soundToggle.classList.toggle('muted', muted);
        });

        function loop(timestamp) {
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            if (dt > 0.05) dt = 0.05;

            // Apply death slow-mo
            if (deathSlowMo) {
                dt *= 0.15; // 15% speed during death
                deathSlowMoTimer -= (timestamp - lastTime) / 1000 * 0.15;
                if (deathSlowMoTimer <= 0) {
                    deathSlowMo = false;
                }
            }

            // 1. Background (Dark Grey Air for Separation)
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'PLAYING' || deathSlowMo) {
                // --- PROXIMITY SCORE MULTIPLIER ---
                const seg = terrain.getSegmentAt(bat.x);
                let proximityBonus = 1.0;
                if (seg) {
                    const distToTop = bat.y - seg.top;
                    const distToBot = seg.bot - bat.y;
                    const minDist = Math.min(distToTop, distToBot);
                    const gapSize = seg.bot - seg.top;

                    // Calculate proximity bonus (closer to wall = higher multiplier)
                    if (minDist < gapSize * 0.2) {
                        proximityBonus = 2.5; // Very close: 2.5x
                        comboStreak += dt;
                    } else if (minDist < gapSize * 0.35) {
                        proximityBonus = 1.5; // Close: 1.5x
                        comboStreak += dt * 0.5;
                    } else {
                        comboStreak = Math.max(0, comboStreak - dt * 2);
                    }

                    // Near-miss detection (very close but not dead)
                    if (minDist < 25 && minDist > 5) {
                        if (nearMissTimer <= 0) {
                            soundSystem.playNearMiss();
                            nearMissTimer = 0.3;
                            // Screen shake
                            const shakeIntensity = 3;
                            canvas.style.transform = `translate(${(Math.random()-0.5)*shakeIntensity}px, ${(Math.random()-0.5)*shakeIntensity}px)`;
                            setTimeout(() => { canvas.style.transform = 'none'; }, 50);
                        }
                    }
                }

                // --- SPEED VARIATION (Rest sections) ---
                speedPhase += dt * 0.3;
                const speedVariation = Math.sin(speedPhase) * 0.15; // Â±15% speed waves
                const targetBaseSpeed = 280 + (score / 6);
                if (targetBaseSpeed > 900) baseSpeed = 900;
                else baseSpeed += (targetBaseSpeed - baseSpeed) * dt * 1.5;

                gameSpeed = baseSpeed * (1 + speedVariation);

                // --- SCORE CALCULATION ---
                let oldScore = Math.floor(score);
                score += (gameSpeed * dt * proximityBonus) / 20;
                let newScore = Math.floor(score);

                // Update display with multiplier indicator
                if (proximityBonus > 1) {
                    scoreDisplay.innerHTML = `DEPTH: ${newScore}m <span style="color: #4f4; font-size: 0.7em;">x${proximityBonus.toFixed(1)}</span>`;
                } else {
                    scoreDisplay.innerText = `DEPTH: ${newScore}m`;
                }

                // --- MILESTONE CELEBRATIONS (every 100m) ---
                const currentMilestone = Math.floor(newScore / 100);
                if (currentMilestone > lastMilestone && newScore > 0) {
                    lastMilestone = currentMilestone;
                    soundSystem.playMilestone();
                    milestoneTimer = 1.5;

                    // Flash effect
                    difficultyDisplay.innerText = `${currentMilestone * 100}m`;
                    difficultyDisplay.style.color = '#4f4';
                    difficultyDisplay.classList.add('warning-active');

                    // Burst of particles
                    fxSystem.addParticles(bat.x, bat.y, 15);
                }

                // Milestone display timer
                if (milestoneTimer > 0) {
                    milestoneTimer -= dt;
                    if (milestoneTimer <= 0) {
                        difficultyDisplay.classList.remove('warning-active');
                        difficultyDisplay.style.color = '#fff';
                    }
                }

                // Difficulty Notification Logic (500m intervals)
                if (Math.floor(oldScore / 500) < Math.floor(newScore / 500) && newScore >= 500) {
                    difficultyDisplay.innerText = "SEISMIC ACTIVITY INCREASED";
                    difficultyDisplay.style.color = '#ff4444';
                    difficultyDisplay.classList.add('warning-active');
                    difficultyTimer = 3.0;
                    soundSystem.playWarning();
                }

                if (difficultyTimer > 0) {
                    difficultyTimer -= dt;
                    if (difficultyTimer <= 0) {
                        difficultyDisplay.classList.remove('warning-active');
                    }
                }

                // Near miss timer
                if (nearMissTimer > 0) {
                    nearMissTimer -= dt;
                }

                // Warning Timer Update
                if (warningTimer > 0) {
                    warningTimer -= dt;
                    if (warningTimer <= 0) {
                        warningDisplay.classList.remove('warning-active');
                    }
                }

                terrain.update(dt);
                const crashed = bat.update(dt);
                fxSystem.update(dt, terrain);

                // Collision Logic
                if (!deathSlowMo && (crashed || terrain.checkCollision(bat))) {
                    // SAFETY NET: First 50m, if you hit floor, bounce up instead of die
                    const isFloorHit = bat.y > canvas.height / 2;

                    if (score < 50 && isFloorHit) {
                        // Activate Safety Net
                        bat.velocity = -350;
                        bat.y = Math.min(bat.y, canvas.height - 60);

                        if (warningTimer <= 0) {
                             soundSystem.playWarning();
                             warningDisplay.classList.add('warning-active');
                             warningTimer = 1.0;
                        }

                        fxSystem.addParticles(bat.x, bat.y + 10, 5);
                    } else {
                        gameOver();
                    }
                }
            } else if (gameState === 'GAMEOVER') {
                fxSystem.update(dt, terrain);
            }

            // Render Order
            fxSystem.draw(ctx);
            terrain.drawMask(ctx); // Solid black rocks
            terrain.draw(ctx); // Grey outlines

            if (gameState !== 'GAMEOVER' || deathSlowMo) {
                bat.draw(ctx);
            }

            requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);

    </script>
</body>
</html>
